<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · ControlSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ControlSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li class="is-active"><a class="tocitem" href>Analysis</a></li><li><a class="tocitem" href="../synthesis/">Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystems.balance"><code>ControlSystems.balance</code></a></li><li><a href="#ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.balreal</code></a></li><li><a href="#ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.baltrunc</code></a></li><li><a href="#ControlSystems.care-NTuple{4, Any}"><code>ControlSystems.care</code></a></li><li><a href="#ControlSystems.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystems.covar</code></a></li><li><a href="#ControlSystems.ctrb-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}"><code>ControlSystems.ctrb</code></a></li><li><a href="#ControlSystems.damp-Tuple{LTISystem}"><code>ControlSystems.damp</code></a></li><li><a href="#ControlSystems.dampreport-Tuple{IO, LTISystem}"><code>ControlSystems.dampreport</code></a></li><li><a href="#ControlSystems.dare-NTuple{4, Any}"><code>ControlSystems.dare</code></a></li><li><a href="#ControlSystems.dcgain-Tuple{LTISystem}"><code>ControlSystems.dcgain</code></a></li><li><a href="#ControlSystems.delaymargin-Tuple{LTISystem}"><code>ControlSystems.delaymargin</code></a></li><li><a href="#ControlSystems.dlyap-Tuple{AbstractMatrix{T} where T, Any}"><code>ControlSystems.dlyap</code></a></li><li><a href="#ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystems.gangoffour</code></a></li><li><a href="#ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}"><code>ControlSystems.gangofseven</code></a></li><li><a href="#ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.gram</code></a></li><li><a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{var&quot;#s249&quot;} where var&quot;#s249&quot;&lt;:Continuous}"><code>ControlSystems.hinfnorm</code></a></li><li><a href="#ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.innovation_form</code></a></li><li><a href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystems.linfnorm</code></a></li><li><a href="#ControlSystems.margin-Tuple{LTISystem, AbstractVector{var&quot;#s245&quot;} where var&quot;#s245&quot;&lt;:Real}"><code>ControlSystems.margin</code></a></li><li><a href="#ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}"><code>ControlSystems.markovparam</code></a></li><li><a href="#ControlSystems.obsv-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}"><code>ControlSystems.obsv</code></a></li><li><a href="#ControlSystems.pole-Tuple{AbstractStateSpace}"><code>ControlSystems.pole</code></a></li><li><a href="#ControlSystems.prescale-Tuple{StateSpace}"><code>ControlSystems.prescale</code></a></li><li><a href="#ControlSystems.reduce_sys-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractFloat}"><code>ControlSystems.reduce_sys</code></a></li><li><a href="#ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.similarity_transform</code></a></li><li><a href="#ControlSystems.tzero-Tuple{TransferFunction}"><code>ControlSystems.tzero</code></a></li><li><a href="#ControlSystems.zpkdata-Tuple{LTISystem}"><code>ControlSystems.zpkdata</code></a></li><li><a href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li></ul><h1 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.damp-Tuple{LTISystem}" href="#ControlSystems.damp-Tuple{LTISystem}"><code>ControlSystems.damp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Wn, zeta, ps = damp(sys)</code></pre><p>Compute the natural frequencies, <code>Wn</code>, and damping ratios, <code>zeta</code>, of the poles, <code>ps</code>, of <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dampreport-Tuple{IO, LTISystem}" href="#ControlSystems.dampreport-Tuple{IO, LTISystem}"><code>ControlSystems.dampreport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dampreport(sys)</code></pre><p>Display a report of the poles, damping ratio, natural frequency, and time constant of the system <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dcgain-Tuple{LTISystem}" href="#ControlSystems.dcgain-Tuple{LTISystem}"><code>ControlSystems.dcgain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dcgain(sys)</code></pre><p>Compute the dcgain of system <code>sys</code>.</p><p>equal to G(0) for continuous-time systems and G(1) for discrete-time systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.delaymargin-Tuple{LTISystem}" href="#ControlSystems.delaymargin-Tuple{LTISystem}"><code>ControlSystems.delaymargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dₘ = delaymargin(G::LTISystem)</code></pre><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L444-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}" href="#ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystems.gangoffour</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">S,D,N,T = gangoffour(P,C; minimal=true)
gangoffour(P::AbstractVector,C::AbstractVector; minimal=true)</code></pre><p>Given a transfer function describing the Plant <code>P</code> and a transfer function describing the controller <code>C</code>, computes the four transfer functions in the Gang-of-Four.</p><ul><li><code>minimal</code> determines whether or not to call <code>minreal</code> on the computed systems.</li><li><code>S = 1/(1+PC)</code> Sensitivity function</li><li><code>D = P/(1+PC)</code></li><li><code>N = C/(1+PC)</code></li><li><code>T = PC/(1+PC)</code> Complementary sensitivity function</li></ul><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L472-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}" href="#ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}"><code>ControlSystems.gangofseven</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">S, D, N, T, RY, RU, RE = gangofseven(P,C,F)</code></pre><p>Given transfer functions describing the Plant <code>P</code>, the controller <code>C</code> and a feed forward block <code>F</code>, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.</p><p><code>S = 1/(1+PC)</code> Sensitivity function</p><p><code>D = P/(1+PC)</code></p><p><code>N = C/(1+PC)</code></p><p><code>T = PC/(1+PC)</code> Complementary sensitivity function</p><p><code>RY = PCF/(1+PC)</code></p><p><code>RU = CF/(1+P*C)</code></p><p><code>RE = F/(1+P*C)</code></p><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L498-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.margin-Tuple{LTISystem, AbstractVector{var&quot;#s245&quot;} where var&quot;#s245&quot;&lt;:Real}" href="#ControlSystems.margin-Tuple{LTISystem, AbstractVector{var&quot;#s245&quot;} where var&quot;#s245&quot;&lt;:Real}"><code>ControlSystems.margin</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ωgₘ, gₘ, ωϕₘ, ϕₘ = margin{S&lt;:Real}(sys::LTISystem, w::AbstractVector{S}; full=false, allMargins=false)</code></p><p>returns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins</p><p>If <code>!allMargins</code>, return only the smallest margin</p><p>If <code>full</code> return also <code>fullPhase</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L314-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}" href="#ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}"><code>ControlSystems.markovparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">markovparam(sys, n)</code></pre><p>Compute the <code>n</code>th markov parameter of state-space system <code>sys</code>. This is defined as the following:</p><p><code>h(0) = D</code></p><p><code>h(n) = C*A^(n-1)*B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L101-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pole-Tuple{AbstractStateSpace}" href="#ControlSystems.pole-Tuple{AbstractStateSpace}"><code>ControlSystems.pole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pole(sys)</code></pre><p>Compute the poles of system <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.reduce_sys-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractFloat}" href="#ControlSystems.reduce_sys-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractFloat}"><code>ControlSystems.reduce_sys</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implements REDUCE in the Emami-Naeini &amp; Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L244-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.tzero-Tuple{TransferFunction}" href="#ControlSystems.tzero-Tuple{TransferFunction}"><code>ControlSystems.tzero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tzero(sys)</code></pre><p>Compute the invariant zeros of the system <code>sys</code>. If <code>sys</code> is a minimal realization, these are also the transmission zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.zpkdata-Tuple{LTISystem}" href="#ControlSystems.zpkdata-Tuple{LTISystem}"><code>ControlSystems.zpkdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">z, p, k = zpkdata(sys)</code></pre><p>Compute the zeros, poles, and gains of system <code>sys</code>.</p><p><strong>Returns</strong></p><p><code>z</code> : Matrix{Vector{ComplexF64}}, (ny x nu)</p><p><code>p</code> : Matrix{Vector{ComplexF64}}, (ny x nu)</p><p><code>k</code> : Matrix{Float64}, (ny x nu)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/analysis.jl#L115-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.balance" href="#ControlSystems.balance"><code>ControlSystems.balance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">S, P, B = balance(A[, perm=true])</code></pre><p>Compute a similarity transform <code>T = S*P</code> resulting in <code>B = T\A*T</code> such that the row and column norms of <code>B</code> are approximately equivalent. If <code>perm=false</code>, the transformation will only scale <code>A</code> using diagonal <code>S</code>, and not permute <code>A</code> (i.e., set <code>P=I</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L455-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.balreal</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sysr, G = balreal(sys::StateSpace)</code></p><p>Calculates a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>G</code></p><p>See also <code>gram</code>, <code>baltrunc</code></p><p>Glad, Ljung, Reglerteori: Flervariabla och Olinjära metoder</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L492-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.baltrunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sysr, G = baltrunc(sys::StateSpace; atol = √ϵ, rtol=1e-3, unitgain=true, n = nothing)</code></pre><p>Reduces the state dimension by calculating a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>G</code>, and truncating it to order <code>n</code>. If <code>n</code> is not provided, it&#39;s chosen such that all states corresponding to singular values less than <code>atol</code> and less that <code>rtol σmax</code> are removed.</p><p>If <code>unitgain=true</code>, the matrix <code>D</code> is chosen such that unit static gain is achieved.</p><p>See also <code>gram</code>, <code>balreal</code></p><p>Glad, Ljung, Reglerteori: Flervariabla och Olinjära metoder</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L535-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.care-NTuple{4, Any}" href="#ControlSystems.care-NTuple{4, Any}"><code>ControlSystems.care</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>care(A, B, Q, R)</code></p><p>Compute &#39;X&#39;, the solution to the continuous-time algebraic Riccati equation, defined as A&#39;X + XA - (XB)R^-1(B&#39;X) + Q = 0, where R is non-singular.</p><p>Algorithm taken from: Laub, &quot;A Schur Method for Solving Algebraic Riccati Equations.&quot; http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.covar-Tuple{AbstractStateSpace, Any}" href="#ControlSystems.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystems.covar</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>P = covar(sys, W)</code></p><p>Calculate the stationary covariance <code>P = E[y(t)y(t)&#39;]</code> of the output <code>y</code> of a <code>StateSpace</code> model <code>sys</code> driven by white Gaussian noise <code>w</code> with covariance <code>E[w(t)w(τ)]=W*δ(t-τ)</code> (δ is the Dirac delta).</p><p>Remark: If <code>sys</code> is unstable then the resulting covariance is a matrix of <code>Inf</code>s. Entries corresponding to direct feedthrough (D<em>W</em>D&#39; .!= 0) will equal <code>Inf</code> for continuous-time systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L148-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.ctrb-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}" href="#ControlSystems.ctrb-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}"><code>ControlSystems.ctrb</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ctrb(A, B)</code> or <code>ctrb(sys)</code></p><p>Compute the controllability matrix for the system described by <code>(A, B)</code> or <code>sys</code>.</p><p>Note that checking for controllability by computing the rank from <code>ctrb</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :c)</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dare-NTuple{4, Any}" href="#ControlSystems.dare-NTuple{4, Any}"><code>ControlSystems.dare</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>dare(A, B, Q, R)</code></p><p>Compute <code>X</code>, the solution to the discrete-time algebraic Riccati equation, defined as A&#39;XA - X - (A&#39;XB)(B&#39;XB + R)^-1(B&#39;XA) + Q = 0, where Q&gt;=0 and R&gt;0</p><p>Algorithm taken from: Laub, &quot;A Schur Method for Solving Algebraic Riccati Equations.&quot; http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L34-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dlyap-Tuple{AbstractMatrix{T} where T, Any}" href="#ControlSystems.dlyap-Tuple{AbstractMatrix{T} where T, Any}"><code>ControlSystems.dlyap</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>dlyap(A, Q)</code></p><p>Compute the solution <code>X</code> to the discrete Lyapunov equation <code>AXA&#39; - X + Q = 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.gram</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>gram(sys, opt)</code></p><p>Compute the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian. If <code>opt</code> is <code>:o</code>, computes the observability grammian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.hinfnorm-Tuple{AbstractStateSpace{var&quot;#s249&quot;} where var&quot;#s249&quot;&lt;:Continuous}" href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{var&quot;#s249&quot;} where var&quot;#s249&quot;&lt;:Continuous}"><code>ControlSystems.hinfnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(Ninf, ω_peak) = hinfnorm(sys; tol=1e-6)</code></p><p>Compute the H∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain Ninf is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code>  if <code>G</code> is stable (σ_max = largest singular value)       :=        <code>Inf&#39;           if</code>G` is unstable</p><p><code>tol</code> is an optional keyword argument for the desired relative accuracy for the computed H∞ norm (not an absolute certificate).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>linfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L220-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.innovation_form</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sysi = innovation<em>form(sys, R1, R2) sysi = innovation</em>form(sys; sysw=I, syse=I, R1=I, R2=I)</p><p>Takes a system</p><pre><code class="language-none">x&#39; = Ax + Bu + w ~ R1
y  = Cx + e ~ R2</code></pre><p>and returns the system</p><pre><code class="language-none">x&#39; = Ax + Kv
y  = Cx + v</code></pre><p>where <code>v</code> is the innovation sequence.</p><p>If <code>sysw</code> (<code>syse</code>) is given, the covariance resulting in filtering noise with <code>R1</code> (<code>R2</code>) through <code>sysw</code> (<code>syse</code>) is used as covariance.</p><p>See Stochastic Control, Chapter 4, Åström</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L608-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.linfnorm-Tuple{AbstractStateSpace}" href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystems.linfnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(Ninf, ω_peak) = linfnorm(sys; tol=1e-6)</code></p><p>Compute the L∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain <code>Ninf</code> is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code> (σ_max denotes the largest singular value)</p><p><code>tol</code> is an optional keyword argument representing the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{var&quot;#s249&quot;} where var&quot;#s249&quot;&lt;:Continuous}"><code>hinfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L248-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.obsv-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}" href="#ControlSystems.obsv-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}"><code>ControlSystems.obsv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>obsv(A, C)</code> or <code>obsv(sys)</code></p><p>Compute the observability matrix for the system described by <code>(A, C)</code> or <code>sys</code>.</p><p>Note that checking for observability by computing the rank from <code>obsv</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :o)</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.prescale-Tuple{StateSpace}" href="#ControlSystems.prescale-Tuple{StateSpace}"><code>ControlSystems.prescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">syst, S = prescale(sys)</code></pre><p>Perform a eigendecomposition on system state-transition matrix <code>sys.A</code>.</p><pre><code class="language-none">Ã = S⁻¹AS
B̃ = S⁻¹ B
C̃ = CS
D̃ = D</code></pre><p>Such that <code>Ã</code> is diagonal. Returns a new scaled state-space object and the associated transformation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L586-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.similarity_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">syst = similarity_transform(sys, T)</code></pre><p>Perform a similarity transform <code>T : Tx̃ = x</code> on <code>sys</code> such that</p><pre><code class="language-none">Ã = T⁻¹AT
B̃ = T⁻¹ B
C̃ = CT
D̃ = D</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L567-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>..  norm(sys, p=2; tol=1e-6)</code></p><p><code>norm(sys)</code> or <code>norm(sys,2)</code> computes the H2 norm of the LTI system <code>sys</code>.</p><p><code>norm(sys, Inf)</code> computes the H∞ norm of the LTI system <code>sys</code>. The H∞ norm is the same as the H∞ for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function <code>hinfnorm</code> instead. See <a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{var&quot;#s249&quot;} where var&quot;#s249&quot;&lt;:Continuous}"><code>hinfnorm</code></a> for further documentation.</p><p><code>tol</code> is an optional keyword argument, used only for the computation of L∞ norms. It represents the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a <code>StateSpace</code> model if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3435695d58e4e5c26c5ff0c8540d326789be6b1/src/matrix_comps.jl#L192-L207">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constructors/">« Constructors</a><a class="docs-footer-nextpage" href="../synthesis/">Synthesis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 4 May 2021 15:10">Tuesday 4 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
